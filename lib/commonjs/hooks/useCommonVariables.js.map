{"version":3,"sources":["useCommonVariables.ts"],"names":["useCommonVariables","props","vertical","height","width","dataLength","defaultIndex","defaultScrollOffsetValue","loop","size","defaultHandlerOffsetValue","Math","abs","_handlerOffset","handlerOffset","prevDataLength","prevSize","previousLength","value","currentLength","isLengthChanged","shouldComputed","direction","previousSize","isSizeChanged","validLength"],"mappings":";;;;;;;AACA;;AAIA;;AACA;;AACA;;AAQO,SAASA,kBAAT,CACLC,KADK,EAEa;AAClB,QAAM;AACJC,IAAAA,QADI;AAEJC,IAAAA,MAFI;AAGJC,IAAAA,KAHI;AAIJC,IAAAA,UAJI;AAKJC,IAAAA,YALI;AAMJC,IAAAA,wBANI;AAOJC,IAAAA;AAPI,MAQFP,KARJ;AASA,QAAMQ,IAAI,GAAGP,QAAQ,GAAGC,MAAH,GAAYC,KAAjC;AACA,QAAMM,yBAAyB,GAAG,CAACC,IAAI,CAACC,GAAL,CAASN,YAAY,GAAGG,IAAxB,CAAnC;;AACA,QAAMI,cAAc,GAAG,2CAAuBH,yBAAvB,CAAvB;;AACA,QAAMI,aAAa,GAAGP,wBAAH,aAAGA,wBAAH,cAAGA,wBAAH,GAA+BM,cAAlD;AACA,QAAME,cAAc,GAAG,2CAAeV,UAAf,CAAvB;AACA,QAAMW,QAAQ,GAAG,2CAAeP,IAAf,CAAjB;AAEA;AACF;AACA;;AACE,kDAAoB,MAAM;AACxB,UAAMQ,cAAc,GAAGF,cAAc,CAACG,KAAtC;AACA,UAAMC,aAAa,GAAGd,UAAtB;AACA,UAAMe,eAAe,GAAGH,cAAc,KAAKE,aAA3C;AACA,UAAME,cAAc,GAAID,eAAe,IAAIZ,IAA3C;AAEA,QAAIa,cAAJ,EACEN,cAAc,CAACG,KAAf,GAAuBb,UAAvB;AAEF,WAAO;AACLgB,MAAAA,cADK;AAELJ,MAAAA,cAFK;AAGLE,MAAAA;AAHK,KAAP;AAKD,GAdD,EAcG,QAAuD;AAAA,QAAtD;AAAEE,MAAAA,cAAF;AAAkBJ,MAAAA,cAAlB;AAAkCE,MAAAA;AAAlC,KAAsD;;AACxD,QAAIE,cAAJ,EAAoB;AAClB;AACA,YAAMC,SAAS,GAAG,oDAAuBR,aAAvB,CAAlB;AAEAA,MAAAA,aAAa,CAACI,KAAd,GAAsB,4DAA2B;AAC/CI,QAAAA,SAD+C;AAE/CL,QAAAA,cAF+C;AAG/CE,QAAAA,aAH+C;AAI/CV,QAAAA,IAJ+C;AAK/CK,QAAAA,aAAa,EAAEA,aAAa,CAACI;AALkB,OAA3B,CAAtB;AAOD;AACF,GA3BD,EA2BG,CAACb,UAAD,EAAaG,IAAb,CA3BH;AA6BA;AACF;AACA;;AACE,kDAAoB,MAAM;AACxB,UAAMe,YAAY,GAAGP,QAAQ,CAACE,KAA9B;AACA,UAAMM,aAAa,GAAGD,YAAY,KAAKd,IAAvC;AACA,UAAMY,cAAc,GAAGG,aAAvB;AAEA,QAAIH,cAAJ,EACEL,QAAQ,CAACE,KAAT,GAAiBT,IAAjB;AAEF,WAAO;AACLY,MAAAA,cADK;AAELE,MAAAA,YAFK;AAGLd,MAAAA;AAHK,KAAP;AAKD,GAbD,EAaG,SAA4C;AAAA,QAA3C;AAAEY,MAAAA,cAAF;AAAkBE,MAAAA,YAAlB;AAAgCd,MAAAA;AAAhC,KAA2C;;AAC7C,QAAIY,cAAJ,EAAoB;AAClBP,MAAAA,aAAa,CAACI,KAAd,GAAsB,4DAA2B;AAC/CJ,QAAAA,aAAa,EAAEA,aAAa,CAACI,KADkB;AAE/CF,QAAAA,QAAQ,EAAEO,YAFqC;AAG/Cd,QAAAA;AAH+C,OAA3B,CAAtB;AAKD;AACF,GArBD,EAqBG,CAACA,IAAD,CArBH;AAuBA,SAAO;AACLA,IAAAA,IADK;AAELgB,IAAAA,WAAW,EAAEpB,UAAU,GAAG,CAFrB;AAGLS,IAAAA;AAHK,GAAP;AAKD","sourcesContent":["import type Animated from \"react-native-reanimated\";\nimport { useSharedValue, useAnimatedReaction } from \"react-native-reanimated\";\n\nimport type { TInitializeCarouselProps } from \"./useInitProps\";\n\nimport { computeOffsetIfDataChanged } from \"../utils/compute-offset-if-data-changed\";\nimport { computeOffsetIfSizeChanged } from \"../utils/compute-offset-if-size-changed\";\nimport { handlerOffsetDirection } from \"../utils/handleroffset-direction\";\n\ninterface ICommonVariables {\n  size: number\n  validLength: number\n  handlerOffset: Animated.SharedValue<number>\n}\n\nexport function useCommonVariables(\n  props: TInitializeCarouselProps<any>,\n): ICommonVariables {\n  const {\n    vertical,\n    height,\n    width,\n    dataLength,\n    defaultIndex,\n    defaultScrollOffsetValue,\n    loop,\n  } = props;\n  const size = vertical ? height : width;\n  const defaultHandlerOffsetValue = -Math.abs(defaultIndex * size);\n  const _handlerOffset = useSharedValue<number>(defaultHandlerOffsetValue);\n  const handlerOffset = defaultScrollOffsetValue ?? _handlerOffset;\n  const prevDataLength = useSharedValue(dataLength);\n  const prevSize = useSharedValue(size);\n\n  /**\n   * When data changes, we need to compute new index for handlerOffset\n  */\n  useAnimatedReaction(() => {\n    const previousLength = prevDataLength.value;\n    const currentLength = dataLength;\n    const isLengthChanged = previousLength !== currentLength;\n    const shouldComputed = (isLengthChanged && loop);\n\n    if (shouldComputed)\n      prevDataLength.value = dataLength;\n\n    return {\n      shouldComputed,\n      previousLength,\n      currentLength,\n    };\n  }, ({ shouldComputed, previousLength, currentLength }) => {\n    if (shouldComputed) {\n      // direction -> 1 | -1\n      const direction = handlerOffsetDirection(handlerOffset);\n\n      handlerOffset.value = computeOffsetIfDataChanged({\n        direction,\n        previousLength,\n        currentLength,\n        size,\n        handlerOffset: handlerOffset.value,\n      });\n    }\n  }, [dataLength, loop]);\n\n  /**\n   * When size changes, we need to compute new index for handlerOffset\n  */\n  useAnimatedReaction(() => {\n    const previousSize = prevSize.value;\n    const isSizeChanged = previousSize !== size;\n    const shouldComputed = isSizeChanged;\n\n    if (shouldComputed)\n      prevSize.value = size;\n\n    return {\n      shouldComputed,\n      previousSize,\n      size,\n    };\n  }, ({ shouldComputed, previousSize, size }) => {\n    if (shouldComputed) {\n      handlerOffset.value = computeOffsetIfSizeChanged({\n        handlerOffset: handlerOffset.value,\n        prevSize: previousSize,\n        size,\n      });\n    }\n  }, [size]);\n\n  return {\n    size,\n    validLength: dataLength - 1,\n    handlerOffset,\n  };\n}\n"]}